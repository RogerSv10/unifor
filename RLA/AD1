Avaliação diagnóstica (AD) consiste em exercícios ou projetos desenvolvidos em grupo ao longo da disciplina.
A primeira avaliação diagnóstica (AD1) será composta por exercícios e equivale a 30% da nota da primeira avaliação (AV1).

Segue abaixo a expressão para o cálculo da AV1, sendo sendo AF1 equivale a primeira avaliação formativa e AD1, a primeira avaliação diagnóstica.


A AD1 é formada pela entrega dos exercícios (EX1) na data prevista e apresentação (AP1) de um dos exercícios escolhido pelo professor. Segue abaixo a expressão para o cálculo da AD1.


A EX1 é avaliada mediante a correção dos exercícios, sendo a avaliação no intervalo de 0% (não atende a questão), 50% (atende parcialmente) e 100% (atende em sua totalidade). Por exemplo, se o exercício equivale a 2 pontos e sua correção atente parcialmente a questão, então sua avaliação deste exercício será 1 ponto.

A AP1 é avaliada mediante aos pré-requisitos de clareza, organização e domínio do conteúdo. Portanto, o aluno deve demonstrar um bom entendimento do algoritmo, explicando seus princípios fundamentais, seu propósito e como ele funciona passo a passo.

A avaliação da AP1 é apenas considerada no intervalo de 0% (não atende os pré-requisitos), 50% (atende parcialmente) e 100% (atende em sua totalidade). Por exemplo, se na apresentação do exercício, o aluno atenter parcialmente os pré-requisitos, então sua avaliação da apresentação será 5,0.

# AD1

### questão 1
Dadas duas variáveis, A e B, implemente e teste um algoritmo para trocar os valores atribuídos a elas.
### pseudocodigo
```
DECLARE x, y, aux INTEIRO
ESCREVA "digite o valor de x:"
LEIA x
ESCREVA "digite o valor de y:"
LEIA y
aux <- y
y <- x
x <- aux
ESCREVAL "x agora vale: ", x"
ESCREVAL "y agora vale: ", y"
```
### FLUXOGRAMA
```mermaid
flowchart TD
a([inicio]) --> b{{digite dois valores: }}
b --> c[/A, B/]
c --> d[auxiliar <-- A]
d --> e[A <-- B]
e --> f[B <-- auxiliar]
f --> g{{o valor de A agora é: A, e o valor de B agora é: B}}
g --> h([fim])
```
### teste de mesa
```
| a  | b  | aux | a  | b  | saída 1 | saída 2 | 
| -- | -- | --  | -- | -- | --      | --      | 
| 0  | 1  | 0   | 1  | 0  | a = 1   | b = 0   |

```

### Questão 2 - Contagem 

Dado um conjunto n de notas de alunos em um exame, implemente e teste um algoritmo para fazer uma contagem cont do número de alunos que foram aprovados no exame. 
Será considerado aprovado o aluno que tirar nota 50 ou maior (no intervalo de 0 a 100).

1. Obter o número de notas n a serem processadas;
2. Inicializar a contagem cont com zero;
3. Enquanto houver notas a serem processadas, fazer repetidamente:
    - obter a próxima nota;
    - se a nota for suficiente para passar no exame (n ≥ 50) então adicionar 1 (um) à contagem $cont$;
4. Exibir a contagem cont (número total de aprovações).
### fluxograma:

```mermaid
flowchart TD
A([INICIO]) --> B{{Digite o número de alunos: }}
B --> C[\n\]
C --> D[\cont = 0\]
D --> E[\i = 1\]
E --> F{i <= n}
F --FALSE--> W{{Número de alunos aprovados: cont}}
W --> Z([FIM])
F --TRUE--> G{{Digite a nota do aluno, i}}
G --> H[\nota\]
H --> I{"nota >= 50 <br>E <br>nota <=100"}
I --TRUE--> J[\cont =+ 1\]
I --FALSE--> K[\i =+ 1\]
J --> K
K --LOOP--> F
```

### Teste de mesa 
```
| it | n  | i  | cont | i<=n  | nota, i | nota | nota_valida | cont+1 | i+1 | saída        | 
| -- | -- | -- | --   | --    | --      | --   | --          | --     | --  | --           |
| 1  | 3  | 1  |  0   | True  | nota 1  | 60   | True        | 1      | 2   |              |
| 2  | 3  | 2  |  1   | True  | nota 2  | 40   | False       | 1      | 3   |              |
| 3  | 3  | 3  |  1   | True  | nota 3  | 90   | True        | 2      | 4   |              |
| 4  | 3  | 4  |  2   | False |         |      |             |        |     | Aprovados: 2 |
```

### Questão 6 - Geração da sequência de Fibonacci 

Gerar e imprimir os n primeiros termos da sequência de Fibonacci, onde n ≥ 1. 
Os primeiros termos são: $0, 1, 1, 2, 3, 5, 8, 13, \dots. Cada termo, além dos dois primeiros, é derivado da soma dos seus dois antecessores mais próximos.

### Fluxograma

```mermaid
flowchart TD
A([INICIO]) --> B{{"Número de termos da série Fibonacci:"}}
B --> C[a = 0]
C --> D[b = 1]
D --> E[[i=1 ATÉ n PASSO 1]]
E --"i > n"--> J([FIM])
E --"i=1,2,...,n"--> F{{a}}
F --> G[termo_atual = a + b]
G --> H[a = b]
H --> I[b = termo_atual]
I --LOOP--> E 
```

### teste de mesa:
```
| it | n  | a  | b  | i  | saída | termo_atual = a + b | a = b | b = termo_atual |
| -- | -- | -- | -- | -- | --    | --                  | --    | --              |
| 1  | 5  | 0  | 1  | 1  | 0     | 0 + 1 = 1           | 1     | 1               |
| 2  | 5  | 1  | 1  | 2  | 1     | 1 + 1 = 2           | 1     | 2               |
| 3  | 5  | 1  | 2  | 3  | 1     | 1 + 2 = 3           | 2     | 3               |
| 4  | 5  | 2  | 3  | 4  | 2     | 2 + 3 = 5           | 3     | 5               |
| 4  | 5  | 3  | 5  | 5  | 3     | 3 + 5 = 8           | 5     | 8               |
```

### pseudocodigo
```
DECLARE  limite, anterior, atual, proximo INTEIRO
ESCREVA("digite o limite da sequencia de fibonacci: ")
   LEIA(limite)
   anterior <- 0
   atual <- 1
   ESCREVA("anterior ->", anterior)
   ESCREVA("atual ->", atual)
   ENQUANTO (atual + anterior <= limite) FACA
       proximo <- atual + anterior
       ESCREVA ("proximo ->", proximo)
       anterior <- atual
       atual <- proximo
   fimenquanto

```





